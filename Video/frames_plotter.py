#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Apr 5 16:20:32 2020

@author: Niels Verleysen

This script can be used to generate the frames for a video by making plots from the data generated by the test_for_video script.

A frame is a plot with the values from the real signal and the predictions at that timestep. Each consecutive frame adds a single timestep.
The plot can show every previous plotted timestep or only a window which is given as parameter.

"""
import csv
from matplotlib import pyplot as plt


"""Main function runs process_one on every given file or file in a given folder after checking if the file has the right naming structure"""
if __name__ == '__main__':

    file = "./Model_128_64_32_K_16/Results.csv"
    output_path = "./Model_128_64_32_K_16/Frames/"
    M = 60
    K = 16
    use_window = True
    window = 800

    with open(file, "r") as input:
        reader = csv.reader(input)
        point = 0

        signal = []
        predictions = []

        i = -2

        for row in reader:
            if i >= 0:      # Skip title
                signal.append(float(row[0]))
                # Set up plot
                plt.yticks([-20, -15, -10, -5, 0, 5, 10, 15, 20], [-20, -15, -10, -5, 0, 5, 10, 15, 20])
                plt.ylim(-21, 21)
            if i >= K:
                # Predictions available
                if len(predictions) > window-M:     # General case
                    start = i-window
                    if start < 0:
                        start = 0
                    x = range(start, i)
                    plt.xlim(start, i)
                    y = signal[start:i]
                    plt.plot(x, y, color='green')
                    plt.plot(i, float(row[i - K + 1]), color='red')

                    new_predictions = []
                    new_predictions.append([float(row[i-K+1])])
                    for j in range(1, len(predictions)+1):
                        if j < M:  # First part of the predictions -> add new prediction
                            predictions[j-1].append(float(row[i - K - j + 1]))
                            new_predictions.append(predictions[j-1])
                            x = range(i - j, i + 1)
                        elif False and i-j < start < i-j+M:  # Last part of the predictions -> remove first prediction
                            predictions[j - 1].pop()
                            new_predictions.append(predictions[j - 1])
                            x = range(start, i-j+M)
                        elif j <= len(predictions):  # Middle part of the predictions -> copy previous predictions
                            new_predictions.append(predictions[j - 1])
                            x = range(i - j, i - j + M)

                        y = predictions[j - 1]
                        plt.plot(x, y, color='red', alpha=0.2)

                else:    # Startup
                    x = range(1, i+1)
                    y = signal[0:i]
                    plt.plot(x, y, color='green')
                    plt.plot(i, float(row[i-K+1]), color='red')

                    new_predictions = []
                    new_predictions.append([float(row[i-K+1])])
                    for j in range(1, i-K):
                        if j < M:
                            # add new prediction
                            predictions[j-1].append(float(row[i - K - j + 1]))
                            new_predictions.append(predictions[j-1])
                            x = range(i - j, i + 1)
                        else:
                            new_predictions.append(predictions[j - 1])
                            x = range(i - j, i - j + M)

                        y = predictions[j-1]
                        plt.plot(x, y, color='red', alpha=0.2)

                predictions = new_predictions

                # Save figure
                plt.savefig(output_path + str(i) + ".png")
                plt.clf()

            i += 1
